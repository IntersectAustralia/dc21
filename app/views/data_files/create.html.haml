- content_for :breadcrumb  do
  %h1 Data / Upload

.container
  .alert.alert-success
    Your files have been uploaded. Below you can modify the information about individual files if you wish.
  = form_tag(bulk_update_data_files_path, :method => :put) do
    - @uploaded_files.each do |file|
      .file-panel{:id => "file_panel_#{file.id}"}
        %h2{:title => file.filename} #{file.filename}
        %ul
          - if file.messages.is_a? Array
            - file.messages.each do |message_attrs|
              %li.alert{:class => message_attrs[:type]}= message_attrs[:message]
        .control-group
          %label.control-label Type:
          .controls
            .record= "#{file.file_processing_status}"

        .control-group
          = label_tag "file_#{file.id}_experiment", "#{@config.level2}", class: "control-label"
          .controls
            = select_tag "files[#{file.id}][experiment_id]", option_groups_from_collection_for_select(grouped_experiments_for_select, :experiments, :name, :id, :name, file.experiment_id), :id => "file_#{file.id}_experiment"

        .control-group
          = label_tag "file_#{file.id}_description", "Description", class: "control-label"
          .controls
            = text_area_tag "files[#{file.id}][file_processing_description]", file.file_processing_description, :id => "file_#{file.id}_description"

        .control-group
          = label_tag "file_#{file.id}_external_id", "ID", class: "control-label"
          .controls
            = text_field_tag "files[#{file.id}][external_id]", file.external_id, :id => "file_#{file.id}_external_id"

        .control-group#tags
          = label_tag :tags, "Tags", class: "control-label"
          .controls
            - if tags.empty?
              .record None
            - tags.each do |tag|
              .record.checkbox
                = check_box_tag "files[#{file.id}][tag_ids][]", tag.id, file.tag_ids.include?(tag.id), :id => "file_#{file.id}_tag_#{tag.id}"
                = label_tag "file_#{file.id}_tag_#{tag.id}", tag.name, :class => 'tag', :title => tag.name
        .control-group#labels
          = label_tag "files[#{file.id}][label_list]", "Labels:", class: "control-label"
          .controls
            = text_field_tag "files[#{file.id}][label_list]", file.labels.pluck(:name).join(','), :class => 'select2_labels', data: {labels: labels}

        - unless file.time_parsable?
          .control-group
            .date-format yyyy-mm-dd
          .control-group
            = label_tag "file_#{file.id}_start_time", "Start Time", class: "control-label"
            .controls
              = text_field_tag "files[#{file.id}][start_time]", @start_time, :id => "file_#{file.id}_start_time", :datepicker => true
              .hidden{:id => "file_#{file.id}_start_container"}
                = select_hour @start_time, {:field_name => "files[#{file.id}][start_hr]"}, {:id => "file_#{file.id}_start_hr"}
                = select_minute @start_time, {:field_name => "files[#{file.id}][start_min]"}, {:id => "file_#{file.id}_start_min"}
                = select_second @start_time, {:field_name => "files[#{file.id}][start_sec]"}, {:id => "file_#{file.id}_start_sec"}
          .control-group
            = label_tag "file_#{file.id}_end_time", "End Time", class: "control-label"
            .controls
              = text_field_tag "files[#{file.id}][end_time]", @end_time, :id => "file_#{file.id}_end_time", :datepicker => true
              .hidden{:id => "file_#{file.id}_end_container"}
                = select_hour @end_time, {:field_name => "files[#{file.id}][end_hr]"}, {:id => "file_#{file.id}_end_hr"}
                = select_minute @end_time, {:field_name => "files[#{file.id}][end_min]"}, {:id => "file_#{file.id}_end_min"}
                = select_second @end_time, {:field_name => "files[#{file.id}][end_sec]"}, {:id => "file_#{file.id}_end_sec"}

          %h2 New File Relationships
          .control-group
            = label_tag "experiment_id_#{file.id}", "Filter Files", class: "control-label"
            .controls
              - dfs = file.experiment.data_files.order(:filename).collect {|a| {id: a.id, text: a.filename, exp_id: a.experiment_id}}
              = select_tag "experiment_id_#{file.id}", option_groups_from_collection_for_select(grouped_experiments_for_select, :experiments, :name, :id, :name, file.experiment_id), data: {df: dfs}, file_id: file.id
              %br/
              Filter data files by #{@config.level2.downcase}
          .control-group
            = label_tag "parent_ids_#{file.id}", "Parents", class: "control-label"
            .controls
              = hidden_field_tag "parent_ids_#{file.id}", nil, data: {placeholder: 'Select parent data files...', values: file.parents.relationship_fields}, name: "files[#{file.id}][parent_ids]"
    .form-actions
      .actions
        = submit_tag "Update"

:javascript
  function Parent($id) {
    var file_id = $id.attr('file_id');
    var data = $id.data('df');

    ////////// START PARENTS //////////
    var $parent_selector = $('#parent_ids_' + file_id);
    var parents = $parent_selector.data('values');

    $parent_selector.select2({
      multiple: true,
      query: function (query){
          var data = {results: []};

          $.each(DC21.preload_data, function(){
            if (validDataFile(this.id) && this.exp_id.toString() == $id.val()){
              if(query.term.length == 0 || this.text.toUpperCase().indexOf(query.term.toUpperCase()) >= 0  ){
                  data.results.push({id: this.id, text: this.text });
              }
            }
          });

          query.callback(data);
      }
    });

    function validDataFile(id) {
      invalid = [file_id];
      $.merge(invalid, $parent_selector.val().split(",") || []);
      $.unique(invalid);
      return $.inArray(id.toString(), invalid) == -1;
    }

    $parent_selector.select2('data', parents);
    ////////// END PARENTS //////////

    var interim_data =  _.indexBy(_.union(parents, data), 'id')
    var DC21 = {preload_data: _.sortBy(_.values(interim_data), 'text')};

    $id.change(function() {
      $.post("/data_files/api_search.json", { experiments: [$id.val()] }, function(data) {
        var new_data = _.map(data, function(df){
          return {id: df.file_id, exp_id: df.experiment_id, text: df.filename};
        });

        interim_data = _.indexBy(_.union(DC21.preload_data, new_data), 'id')
        DC21.preload_data = _.sortBy(_.values(interim_data), 'text');
      },
      "json");
    });
  }

  $('.select2_labels').select2({tags: $('.select2_labels').data('labels'), tokenSeparators: ['|'], separator: '|'})

  ////////// INIT //////////
  $('select[id^="experiment_id_"]').each(function(index) {
    new Parent($(this));
  });


